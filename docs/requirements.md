# ハーツゲーム Webアプリケーション 要件定義書

## 1. 概要

### 1.1 システム概要
- 4人の人間プレイヤーによるハーツゲーム（トリックテイキングゲーム）
- PCブラウザ専用のWebアプリケーション
- サーバーを介したリアルタイムマルチプレイヤー対戦
- プライベート環境での使用を前提とした軽量・シンプルな設計

### 1.2 基本仕様
- 52枚のトランプを使用（ジョーカーなし）
- 各プレイヤーに13枚ずつ配布
- ハートのカードとスペードのクイーンを取らないことが目標
- 100点に達したプレイヤーが出た時点でゲーム終了、最少得点者が勝利

## 2. ゲームルール

### 2.1 基本ルール
- 最初の手番：クラブの2を持つプレイヤーが開始
- カード交換フェーズ：ゲーム開始前に指定された3枚を隣のプレイヤーと交換
- 最初のトリックではハートとスペードのクイーンは出せない
- ハートが場に出るまでハートでリードできない（ハートブレイク）
- 各ラウンド終了時にペナルティポイントを計算

### 2.2 得点計算
- ハートのカード：1枚につき1点のペナルティ
- スペードのクイーン：13点のペナルティ
- シュートザムーン：全てのペナルティカードを取った場合、他プレイヤーに26点追加

## 3. ユーザ管理仕様

### 3.1 ユーザ登録
- 4名固定のユーザ（プレイヤー1、プレイヤー2、プレイヤー3、プレイヤー4）
- 認証機能なし（パスワード不要）
- ユーザ登録・削除機能なし

### 3.2 ログイン仕様
- ログイン画面でユーザを選択するだけでログイン
- 同じユーザに後からログインすると既存セッションを上書き
- 重複ログイン時は既存セッションを強制切断

```
ログイン画面レイアウト：
┌─────────────────────────────────────┐
│          ハーツゲーム                │
│    プレイヤーを選択してください      │
│  ┌─────────┐ ┌─────────┐           │
│  │プレイヤー1│ │プレイヤー2│           │
│  └─────────┘ └─────────┘           │
│  ┌─────────┐ ┌─────────┐           │
│  │プレイヤー3│ │プレイヤー4│           │
│  └─────────┘ └─────────┘           │
└─────────────────────────────────────┘
```

## 4. ゲーム進行仕様

### 4.1 タイムアウト仕様
- **タイムアウトなし**：各プレイヤーは制限時間なく考えることが可能
- カード選択、カード交換フェーズともに時間制限なし
- 「考慮中」「待機中」のステータス表示のみ

### 4.2 切断・再接続機能
- WebSocket接続の監視により切断を自動検知
- ユーザが切断された場合、ゲームを一時停止
- 切断ユーザの再ログインでゲーム自動再開
- ゲーム状態の完全保持・復元

```
一時停止画面：
┌─────────────────────────────────────┐
│     ゲーム一時停止中                 │
│  Player2 が切断されました           │
│  再接続をお待ちください...           │
│  ハンド: 3/4  トリック: 7/13        │
└─────────────────────────────────────┘
```

### 4.3 待機室機能
- 4名全員がログインするまで待機
- プレイヤー接続状況の表示
- 全員揃ったら自動でゲーム開始

## 5. UI/UX仕様

### 5.1 対応環境
- **PCブラウザ専用**（レスポンシブ対応不要）
- 想定解像度：1280x720以上
- モダンブラウザ対応（Chrome、Firefox、Edge、Safari）

### 5.2 画面レイアウト
```
メイン画面構成：
┌─────────────────┬──────────────┐
│   ゲーム盤面     │ スコア表示    │
│                 │ ・グラフ      │
│                 │ ・順位表      │
├─────────────────┤ ・統計情報    │
│   手札エリア     │              │
└─────────────────┴──────────────┘
```

### 5.3 操作仕様
- クリックベースの基本操作
- キーボードショートカット（基本的なもの）
- 直感的なボタン配置

### 5.4 デザイン方針
- シンプルで実用的なデザイン
- リッチなグラフィック・エフェクトは不要
- 軽量で高速な動作を重視
- 見やすく分かりやすいUI

## 6. スコア可視化機能

### 6.1 グラフ表示
- **リアルタイム更新**：各ハンド終了後に自動更新
- **表示内容**：4人プレイヤーの累積スコア推移
- **グラフ種類**：シンプルな折れ線グラフ
- **配置**：ゲーム画面右側に常時表示

### 6.2 グラフ機能
- 4色の線による各プレイヤーの識別
- X軸：ハンド数、Y軸：累積ペナルティポイント
- マウスホバーでの詳細情報表示
- 基本的なツールチップ表示

### 6.3 スコア表示
- 現在の順位表示
- 各ハンドの得点内訳
- シュートザムーン等の特別得点表示

## 7. ゲーム履歴記録機能

### 7.1 記録データ
- **配布カード**：各プレイヤーの初期手札
- **カード交換履歴**：誰が誰に何のカードを渡したか
- **トリック詳細**：各トリックで出されたカード順、勝者、獲得ポイント
- **スコア変化**：ハンド終了時のスコア変化

### 7.2 データ構造
```javascript
{
  gameId: "game_001",
  players: ["プレイヤー1", "プレイヤー2", "プレイヤー3", "プレイヤー4"],
  hands: [
    {
      handNumber: 1,
      initialCards: {
        "プレイヤー1": ["AH", "KH", "QH", ...],
        // ...
      },
      cardExchange: {
        "プレイヤー1": { given: ["AH", "KH", "QH"], received: ["2C", "3C", "4C"] },
        // ...
      },
      tricks: [
        {
          trickNumber: 1,
          cardsPlayed: [
            { player: "プレイヤー1", card: "2C" },
            // ...
          ],
          winner: "プレイヤー4",
          points: 0
        }
      ],
      handScores: { "プレイヤー1": 5, "プレイヤー2": 0, ... }
    }
  ]
}
```

### 7.3 履歴閲覧機能
- **ゲーム終了後の閲覧**：専用の履歴閲覧画面
- **階層表示**：ハンド選択→トリック選択
- **詳細表示**：配布カード、交換カード、各トリックの詳細
- **ナビゲーション**：ハンド間・トリック間の移動機能

### 7.4 表示内容
1. **ハンド一覧**：各ハンドのサマリー表示
2. **ハンド詳細**：配布カード、交換カード、トリック一覧
3. **トリック詳細**：4枚のカード配置、勝者、獲得ポイント

## 8. 技術仕様

### 8.1 アーキテクチャ
- **フロントエンド**：HTML/CSS/JavaScript
- **バックエンド**：Node.js + Express + Socket.io（推奨）
- **通信**：WebSocketによるリアルタイム通信
- **データ保存**：メモリベース（永続化は最小限）

### 8.2 使用ライブラリ
- **グラフ表示**：Chart.js
- **リアルタイム通信**：Socket.io
- **UI フレームワーク**：バニラJSまたは軽量フレームワーク

### 8.3 データベース仕様
- **データベース**：PostgreSQL
- **永続化データ**：ゲームスコア、ハンド詳細、開始・終了時刻
- **一時データ**：現在のゲーム状態（メモリ管理）
- **履歴保持期間**：無制限（ディスク容量に依存）
- **JSON サポート**：PostgreSQLのJSONB型を活用

### 8.4 セキュリティ仕様
- **最小限の不正防止**：基本的なルール違反チェックのみ
- **手札の隠蔽**：他プレイヤーのカードは非表示
- **ターン制御**：ターン外操作の制限
- 複雑な認証・暗号化は不要（プライベート環境前提）

### 8.5 パフォーマンス要件
- 軽量で高速な動作
- 必要最小限のアニメーション
- メモリ効率的なデータ管理
- 複数ブラウザタブでの同時表示サポート

## 9. データベース設計

別途スキーマ,ER図参照

## 10. データ管理

### 10.1 セッション管理
- プレイヤーの一意識別（ユーザ名 + sessionID）
- **ゲーム状態**：メモリ内で管理（リアルタイム用）
- **永続データ**：データベースに保存（履歴・統計用）
- 再接続時の認証・状態復元

### 10.2 状態保持
```javascript
// メモリ内のゲーム状態（リアルタイム用）
const gameSession = {
  gameId: 123, // データベースのgames.id
  activePlayers: {
    "プレイヤー1": { socket: socket1, status: "connected" },
    "プレイヤー2": { socket: socket2, status: "connected" },
    "プレイヤー3": null, // 未接続
    "プレイヤー4": null
  },
  gameState: {
    currentHand: 1,
    currentTrick: 1,
    currentTurn: "プレイヤー1",
    // 現在進行中のゲーム状態
  }
};
```

### 10.3 データ保存方針
- **リアルタイムデータ**：メモリ内で高速処理
- **履歴データ**：データベースに永続保存
- **統計データ**：定期的にデータベースから集計
- **バックアップ**：SQLiteファイルまたはDBダンプ

### 10.4 データベース操作
```javascript
// ゲーム開始時
async function startNewGame(db) {
    const result = await db.query(
        'INSERT INTO games (start_time, status) VALUES (NOW(), $1) RETURNING id',
        ['playing']
    );
    return result.rows[0].id;
}

// ハンド終了時
async function saveHandData(db, gameId, handData) {
    await db.query(`
        INSERT INTO hands (
            game_id, hand_number, initial_cards, card_exchanges, 
            tricks, hand_scores, cumulative_scores
        ) VALUES ($1, $2, $3, $4, $5, $6, $7)`,
        [
            gameId, 
            handData.handNumber, 
            JSON.stringify(handData.initialCards),
            JSON.stringify(handData.cardExchanges), 
            JSON.stringify(handData.tricks),
            JSON.stringify(handData.handScores), 
            JSON.stringify(handData.cumulativeScores)
        ]
    );
}

// ゲーム終了時
async function finishGame(db, gameId, finalScores, winner) {
    const client = await db.getClient();
    try {
        await client.query('BEGIN');
        
        // ゲーム情報更新
        await client.query(`
            UPDATE games 
            SET end_time = NOW(), status = $1, final_scores = $2, winner = $3, updated_at = NOW()
            WHERE id = $4`,
            ['finished', JSON.stringify(finalScores), winner, gameId]
        );
        
        // 各プレイヤーの統計更新
        for (const [playerName, score] of Object.entries(finalScores)) {
            const isWinner = playerName === winner ? 1 : 0;
            await client.query(`
                INSERT INTO game_statistics (player_name, total_games, wins, average_score, best_score, worst_score)
                VALUES ($1, 1, $2, $3, $3, $3)
                ON CONFLICT (player_name) DO UPDATE SET
                    total_games = game_statistics.total_games + 1,
                    wins = game_statistics.wins + $2,
                    average_score = (
                        (game_statistics.average_score * game_statistics.total_games + $3) 
                        / (game_statistics.total_games + 1)
                    ),
                    best_score = LEAST(game_statistics.best_score, $3),
                    worst_score = GREATEST(game_statistics.worst_score, $3),
                    updated_at = NOW()`,
                [playerName, isWinner, score]
            );
        }
        
        await client.query('COMMIT');
    } catch (error) {
        await client.query('ROLLBACK');
        throw error;
    } finally {
        client.release();
    }
}
```

## 11. 履歴・統計機能

### 11.1 ゲーム履歴一覧画面
- **表示内容**：過去のゲーム一覧（日時、参加者、最終スコア、勝者）
- **ソート機能**：日時順、勝者別、スコア順
- **フィルタ機能**：期間指定、特定プレイヤー参加ゲーム
- **詳細表示**：ゲーム選択で詳細履歴画面へ遷移

### 11.2 プレイヤー統計画面
```javascript
// 表示する統計情報
{
    "プレイヤー1": {
        totalGames: 25,
        wins: 8,
        winRate: 32.0,
        averageScore: 67.3,
        bestScore: 23,
        worstScore: 103,
        recentForm: [45, 67, 23, 89, 34] // 直近5ゲーム
    }
    // ...
}
```

### 11.3 ゲーム統計ダッシュボード
- **全体統計**：総ゲーム数、平均ゲーム時間、最高/最低スコア
- **プレイヤー比較**：勝率、平均スコアの比較グラフ
- **傾向分析**：時期別のプレイ頻度、スコア推移
- **記録**：最短ゲーム時間、最長ゲーム時間、連勝記録

## 12. エラーハンドリング

### 10.1 切断対応
- 24時間後の自動ゲーム破棄
- 複数プレイヤー切断時の段階的復旧
- データ整合性チェック

### 10.2 例外処理
- 不正な再接続の拒否
- 重複接続の防止
- ネットワークエラーの適切な表示

### 12.1 切断対応
- 24時間後の自動ゲーム破棄
- 複数プレイヤー切断時の段階的復旧
- データ整合性チェック
- **データベース整合性**：ゲーム中断時のデータ保存

### 12.2 例外処理
- 不正な再接続の拒否
- 重複接続の防止
- ネットワークエラーの適切な表示
- **データベースエラー**：接続失敗時の適切な処理

### 12.3 データベースエラー対応
```javascript
// データベース接続エラー時の処理
try {
    await saveHandData(gameId, handData);
} catch (error) {
    console.error('Database save failed:', error);
    // メモリ内データは保持し、後で再試行
    retryQueue.push({ type: 'saveHand', data: handData });
}
```

## 13. 実装優先順位

### Phase 1（最小機能）
- 基本ゲームロジック
- 4人同時プレイ
- シンプルなユーザ選択ログイン
- リアルタイム同期
- **基本的なデータベース保存**（ゲーム開始・終了記録）

### Phase 2（利便性向上）
- スコア推移グラフ
- 切断・再接続機能
- 基本的なエラーハンドリング
- **ハンド詳細のデータベース保存**

### Phase 3（体験向上）
- ゲーム履歴記録・閲覧
- UI/UXの向上
- **統計機能・履歴一覧画面**
- データベース最適化

## 14. 非機能要件

### 14.1 省略する機能
- レスポンシブ対応
- 3Dエフェクト・リッチアニメーション
- 複雑な認証システム
- マルチウィンドウ表示
- 暗号化（HTTPS推奨程度）

### 14.2 運用要件
- ローカルネットワークでの使用を想定
- 軽量なサーバー環境での動作
- 簡単な保守・更新が可能な構成

### 14.3 推奨技術スタック
- **フロントエンド**：HTML/CSS/JavaScript
- **バックエンド**：Node.js + Express + Socket.io
- **データベース**：PostgreSQL
- **DB接続**：Prisma ORM
- **リアルタイム通信**：Socket.io
- **グラフ表示**：Chart.js

### 14.4 PostgreSQL設定推奨事項
```sql
-- データベース作成
CREATE DATABASE hearts_game 
WITH ENCODING='UTF8' 
LC_COLLATE='ja_JP.UTF-8' 
LC_CTYPE='ja_JP.UTF-8';

-- 接続設定例
postgresql://username:password@localhost:5432/hearts_game
```

### 14.5 環境構築
- **開発環境**：Docker Compose使用推奨
- **本番環境**：PostgreSQL 13以上
- **バックアップ**：pg_dump による定期バックアップ

## 15. 追加要件（優先度低）

### 15.1 席順のランダム化
- 現在の着席順（先着順）ではなく、ランダムな席順で配置
- ゲーム開始時に4人のプレイヤーを東西南北にランダム配置
- 戦略性向上とゲームの公平性確保

### 15.2 手札ソート順の変更
- 現在のソート順から変更：左からクラブ、ダイヤ、スペード、ハートの順
- 一般的なブリッジゲームの並び順に準拠
- プレイヤーの慣れた配置での手札管理

### 15.3 カード絵柄の画像化
- 現在のテキスト表示（♠、♥、♦、♣）から画像ファイルへの変更
- より視覚的で直感的なカード表示
- カードデザインの美観向上

### 15.4 ログイン→ゲーム参加の簡素化
- 現在の「プレイヤー選択 → ロビー → ゲーム参加」フローの短縮
- プレイヤー選択画面から直接ゲーム参加
- より直感的でスムーズなユーザー体験
